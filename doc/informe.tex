% ******************************************************** %
%              TEMPLATE DE INFORME ORGA2 v0.1              %
% ******************************************************** %
% ******************************************************** %
%                                                          %
% ALGUNOS PAQUETES REQUERIDOS (EN UBUNTU):                 %
% ========================================
%                                                          %
% texlive-latex-base                                       %
% texlive-latex-recommended                                %
% texlive-fonts-recommended                                %
% texlive-latex-extra?                                     %
% texlive-lang-spanish (en ubuntu 13.10)                   %
% ******************************************************** %


\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{charter}   % tipografia
\usepackage{tipa}
\usepackage{graphicx}
%\usepackage{makeidx}
\usepackage{paralist} %itemize inline

%\usepackage{float}
%\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsfonts}
%\usepackage{sectsty}
%\usepackage{charter}
%\usepackage{wrapfig}
%\usepackage{listings}
%\lstset{language=C}

% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}


% ********************************************************* %
% ~~~~~~~~              Code snippets             ~~~~~~~~~ %
% ********************************************************* %

\usepackage{color} % para snipets de codigo coloreados
\usepackage{fancybox}  % para el sbox de los snipets de codigo

\definecolor{litegrey}{gray}{0.94}

\newenvironment{codesnippet}{%
	\begin{Sbox}\begin{minipage}{\textwidth}\sffamily\small}%
	{\end{minipage}\end{Sbox}%
		\begin{center}%
		\vspace{-0.4cm}\colorbox{litegrey}{\TheSbox}\end{center}\vspace{0.3cm}}



% ********************************************************* %
% ~~~~~~~~         Formato de las páginas         ~~~~~~~~~ %
% ********************************************************* %

\usepackage{fancyhdr}
\pagestyle{fancy}

%\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ - #1}}

\fancyhf{}

\fancyhead[LO]{Sección \rightmark} % \thesection\ 
\fancyfoot[LO]{\small{Nombre Apellido, Nombre Apellido, Nombre Apellido}}
\fancyfoot[RO]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
\setlength{\hoffset}{-0.8in}
\setlength{\textwidth}{16cm}
%\setlength{\hoffset}{-1.1cm}
%\setlength{\textwidth}{16cm}
\setlength{\headsep}{0.5cm}
\setlength{\textheight}{25cm}
\setlength{\voffset}{-0.7in}
\setlength{\headwidth}{\textwidth}
\setlength{\headheight}{13.1pt}

\renewcommand{\baselinestretch}{1.1}  % line spacing

% ******************************************************** %


\begin{document}


\thispagestyle{empty}
\materia{Organización del Computador II}
\submateria{Primer Cuatrimestre de 2019}
\titulo{Trabajo Práctico II}
\subtitulo{subtítulo del trabajo}
\integrante{Nombre}{XXX/XX}{mail}
\integrante{Nombre}{XXX/XX}{mail}

\maketitle
\newpage

\thispagestyle{empty}
\vfill
\begin{abstract}
En el presente trabajo se describe la problemática de ...
\end{abstract}

\thispagestyle{empty}
\vspace{3cm}
\tableofcontents
\newpage


%\normalsize
\newpage

\section{Introducción}

SIMD (single instruction, multiple data) es una arquitectura de computaci\'on centrada en el procesamiento simultaneo una operaci\'on sobre varios datos mediante una \'unica isntrucci\'on. Tal t\'ecnica suele ser aplicada para trabajar de manera eficiente sobre vectores y matrices de datos. \par
El objetivo de este trabajo pr\'actico es consolidar los conocimientos adquiridos en las clases sobre SIMD. Utilizando esta arquitectura implementaremos distintos algoritmos en ASM creando filtros sobre imágenes para luego comparar su rendimiento con una implementación en C.


\section{Desarrrollo}

\begin{figure}
  \begin{center}
	\includegraphics[scale=0.66]{img/logouba.jpg}
	\caption{Descripcion de la figura}
	\label{nombreparareferenciar}
  \end{center}
\end{figure}

\subsection{Imagen Fantasma}

\subsubsection{Descripci\'on}

\paragraph Bla bla bla bla.
Esto se muestra en la figura~\ref{Imagen fantasma}.

\subsubsection{Implementaci\'on}

el code snippet lo deje por las dudas, por si lo necesito hago copy paste


\begin{codesnippet}
\begin{verbatim}

struct Pepe {

    ...

};

\end{verbatim}
\end{codesnippet}

\subsection{ReforzarBrillo}

\subsubsection{Descripción}

Este filtro aumenta y disminuye el brillo de una imagen según el brillo que ya tenia. Sí el
pixel supera un umbral, el brillo se aumenta, si el pixel esta debajo de un umbral, el brillo se
disminuye. El efecto resultante es un refuerzo del brillo diferenciado.

\subsubsection{Implementaci\'on}

En este filtro consideramos varias cosas a la hora de implementar este filtro.

Para poder detenerminar si un pixel superaba un estaba por debajo de un umbral, necesitabamos hacer la siguiente cuenta:

\begin{center}
	b = ( pixel.R + 2 * pixel.G + pixel.B ) / 4
\end{center}

Seguido a esto, ya que cada componente de un pixel mide 1 byte, dando que el tama\~no total de un pixel es de 4 bytes, en un registro xmm podemos levantar 4 pixeles. Sin embargo, si queremos que nuestra cuenta sea exacta, fue necesario extender el tama\~no de cada componente a 2 bytes. Para esto, en vez de utilizar una instruccion de extension de como pmovzxbw, decidimos utilizar la instrucción de pshufb con una mascara que nos dejá de la componente Verde en la posicion en la que deberia estar la transparencia. Quedando el registro xmm de la siguiente forma: 

\begin{center}
	xmm = [ G1 \textpipe\ R1 \textpipe\ G1 \textpipe\ B1 \textpipe\ G0 \textpipe\ R0 \textpipe\ G0 \textpipe\ B0 ]
\end{center}

Esto nos facilit\'o la suma, ya que solo tuvimos que usar la suma horizontal quedando el registro xmm:

\begin{center}
	xmm = [ 0 \textpipe\ 0 \textpipe\ 0 \textpipe\ 0 \textpipe\ G1 + R1 \textpipe\ G1 + B1 \textpipe\ G0 + R0 \textpipe\ G0 + B0 ]
\end{center}

y si usamos nuevamente la suma horizontal nuevamente obtendremos:

\begin{center}
	xmm = [ 0 \textpipe\ 0 \textpipe\ 0 \textpipe\ 0 \textpipe\ 0 \textpipe\ 0 \textpipe\ R1 + 2 $\times$ G1 + B1 \textpipe\ R0 + 2 $\times$ G0 + B0 ]
\end{center}

Finalmente divisimos por 4 usando un shift empaquetado de a word de 2 bits a derecha para que nos quede b, como nosotros queriamos.

Ahora, para poder compararlos con los umbrales que pueden ser numeros de hasta 4 bytes, es necesario extender nuevamente de word a dword (2 a 4 bytes) quedando los b de cada pixel expresados en dwords.

Una vez que tenemos nuestros b, pasamos a analizar cual b es mayor o menor a los umbrales pasados por parametro. Sabemos que como estamos preguntando por mayor o menor estrictos, no es posible que un b cumpla ambas condiciones al mismo tiempo (?????? estoy super exceptico con respecto a esto).

\section{Resultados}
%\input{enunciado}

\section{Conclusión}


\end{document}

